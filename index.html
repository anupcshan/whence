<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Whence - Location History</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; font-family: system-ui, -apple-system, sans-serif; }

        /* Navigation */
        #nav {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: white;
            padding: 6px;
            border-radius: 6px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            display: flex;
            gap: 4px;
        }
        #nav a {
            padding: 8px 16px;
            border: none;
            background: transparent;
            cursor: pointer;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 500;
            text-decoration: none;
            color: inherit;
        }
        #nav a:hover { background: #f0f0f0; }
        #nav a.active { background: #007bff; color: white; }

        /* Map View */
        #map { height: 100%; width: 100%; }
        #controls {
            position: absolute;
            top: 60px;
            right: 10px;
            z-index: 1000;
            background: white;
            padding: 12px;
            border-radius: 6px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            width: 180px;
        }
        #controls label { display: block; margin-bottom: 4px; font-size: 12px; color: #666; }
        #controls input { width: 100%; margin-bottom: 10px; padding: 6px; border: 1px solid #ddd; border-radius: 4px; }
        #controls button { 
            width: 100%; 
            padding: 8px; 
            cursor: pointer;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            font-weight: 500;
        }
        #controls button:hover { background: #0056b3; }
        #status {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.5); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }
        .current-marker { animation: pulse 2s infinite; }
    </style>
</head>
<body>
    <div id="nav">
        <a href="/" class="active">Map</a>
        <a href="/import">Import</a>
    </div>

    <div id="map"></div>
    <div id="controls">
        <label>Start Date</label>
        <input type="date" id="startDate">
        <label>End Date</label>
        <input type="date" id="endDate">
        <button id="applyFilter">Apply Filter</button>
    </div>
    <div id="status">Paths: 0, Points: 0</div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
    <script>
        // Map initialization
        const map = L.map('map').setView([0, 0], 2);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap contributors'
        }).addTo(map);

        let pathsLayer = L.layerGroup().addTo(map);
        let currentLayer = L.layerGroup().addTo(map);

        function formatDateTime(timestamp) {
            const d = new Date(timestamp * 1000);
            const now = new Date();
            const isToday = d.toDateString() === now.toDateString();
            const yesterday = new Date(now);
            yesterday.setDate(yesterday.getDate() - 1);
            const isYesterday = d.toDateString() === yesterday.toDateString();

            const time = d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

            if (isToday) {
                return `Today ${time}`;
            } else if (isYesterday) {
                return `Yesterday ${time}`;
            } else {
                const date = d.toLocaleDateString(undefined, { month: 'short', day: 'numeric', year: 'numeric' });
                return `${date} ${time}`;
            }
        }

        function formatDuration(seconds) {
            const mins = Math.floor(seconds / 60);
            const hrs = Math.floor(mins / 60);
            const days = Math.floor(hrs / 24);

            if (days > 0) {
                const remainingHrs = hrs % 24;
                return `${days}d ${remainingHrs}h`;
            }
            if (hrs > 0) {
                const remainingMins = mins % 60;
                return `${hrs}h ${remainingMins}m`;
            }
            return `${mins}m`;
        }

        // Minimum time gap (seconds) to consider a point as a "stop"
        const STOP_GAP_SECONDS = 10 * 60; // 10 minutes

        function renderPaths(data) {
            pathsLayer.clearLayers();
            currentLayer.clearLayers();

            if (data.paths) {
                data.paths.forEach(path => {
                    if (!path.points || path.points.length === 0) return;

                    const latlngs = path.points.map(p => [p.lat, p.lon]);

                    // Draw the path line
                    const polyline = L.polyline(latlngs, {
                        color: '#3498db',
                        weight: 3,
                        opacity: 0.8
                    }).bindPopup(`
                        <strong>${path.date}</strong><br>
                        ${path.point_count} points
                    `).addTo(pathsLayer);

                    // Add direction arrows along the path
                    addDirectionArrows(polyline, pathsLayer);

                    // Detect stops and add markers
                    for (let i = 0; i < path.points.length; i++) {
                        const point = path.points[i];
                        const nextPoint = path.points[i + 1];

                        let isStop = false;
                        let stopDuration = 0;

                        if (nextPoint) {
                            stopDuration = nextPoint.timestamp - point.timestamp;
                            isStop = stopDuration >= STOP_GAP_SECONDS;
                        } else if (i === path.points.length - 1 && path.points.length > 1) {
                            isStop = true;
                        }

                        if (i === 0) {
                            L.circleMarker([point.lat, point.lon], {
                                radius: 7,
                                fillColor: '#27ae60',
                                color: '#1e8449',
                                weight: 2,
                                opacity: 1,
                                fillOpacity: 0.9
                            }).bindPopup(`<strong>Start</strong><br>${formatDateTime(point.timestamp)}`)
                              .addTo(pathsLayer);
                        } else if (isStop) {
                            const popupContent = stopDuration > 0 
                                ? `<strong>Stopped ${formatDuration(stopDuration)}</strong><br>${formatDateTime(point.timestamp)}`
                                : `<strong>End</strong><br>${formatDateTime(point.timestamp)}`;

                            L.circleMarker([point.lat, point.lon], {
                                radius: 7,
                                fillColor: '#e74c3c',
                                color: '#c0392b',
                                weight: 2,
                                opacity: 1,
                                fillOpacity: 0.9
                            }).bindPopup(popupContent)
                              .addTo(pathsLayer);
                        }
                    }
                });
            }

            if (data.current) {
                const currentIcon = L.divIcon({
                    className: 'current-marker',
                    html: `<div style="
                        width: 16px;
                        height: 16px;
                        background: #2ecc71;
                        border: 3px solid #27ae60;
                        border-radius: 50%;
                    "></div>`,
                    iconSize: [16, 16],
                    iconAnchor: [8, 8]
                });
                L.marker([data.current.lat, data.current.lon], { icon: currentIcon })
                    .bindPopup(`Current: ${formatDateTime(data.current.timestamp)}`)
                    .addTo(currentLayer);
            }

            const pathCount = data.paths ? data.paths.length : 0;
            const pointCount = data.paths ? data.paths.reduce((sum, p) => sum + (p.point_count || 0), 0) : 0;
            document.getElementById('status').textContent = `Paths: ${pathCount}, Points: ${pointCount}`;
        }

        function addDirectionArrows(polyline, layer) {
            const latlngs = polyline.getLatLngs();
            if (latlngs.length < 2) return;

            const totalPoints = latlngs.length;
            const arrowInterval = Math.max(1, Math.floor(totalPoints / 8));

            for (let i = arrowInterval; i < totalPoints - 1; i += arrowInterval) {
                const start = latlngs[i - 1];
                const end = latlngs[i];

                const angle = Math.atan2(end.lng - start.lng, end.lat - start.lat) * 180 / Math.PI;

                const arrowIcon = L.divIcon({
                    className: 'direction-arrow',
                    html: `<div style="
                        transform: rotate(${angle}deg);
                        color: #2980b9;
                        font-size: 14px;
                        font-weight: bold;
                        text-shadow: 0 0 2px white, 0 0 2px white;
                    ">&#9650;</div>`,
                    iconSize: [14, 14],
                    iconAnchor: [7, 7]
                });

                L.marker(end, { icon: arrowIcon, interactive: false }).addTo(layer);
            }
        }

        function fetchPaths() {
            const bounds = map.getBounds();
            const bbox = [
                bounds.getWest(),
                bounds.getSouth(),
                bounds.getEast(),
                bounds.getNorth()
            ].join(',');

            let url = `/api/paths?bbox=${bbox}`;

            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;

            if (startDate) {
                url += `&start=${Math.floor(new Date(startDate).getTime() / 1000)}`;
            }
            if (endDate) {
                const end = new Date(endDate);
                end.setHours(23, 59, 59, 999);
                url += `&end=${Math.floor(end.getTime() / 1000)}`;
            }

            fetch(url)
                .then(r => r.json())
                .then(renderPaths)
                .catch(err => console.error('Failed to fetch paths:', err));
        }

        map.on('moveend', fetchPaths);
        document.getElementById('applyFilter').addEventListener('click', fetchPaths);

        fetch('/api/latest')
            .then(r => r.json())
            .then(loc => {
                if (loc) {
                    map.setView([loc.lat, loc.lon], 13);
                } else {
                    fetchPaths();
                }
            })
            .catch(() => fetchPaths());
    </script>
</body>
</html>
