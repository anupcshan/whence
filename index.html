<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Whence - Location History</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; font-family: system-ui, -apple-system, sans-serif; }

        /* Navigation */
        #nav {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: white;
            padding: 6px;
            border-radius: 6px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            display: flex;
            gap: 4px;
        }
        #nav a {
            padding: 8px 16px;
            border: none;
            background: transparent;
            cursor: pointer;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 500;
            text-decoration: none;
            color: inherit;
        }
        #nav a:hover { background: #f0f0f0; }
        #nav a.active { background: #007bff; color: white; }

        /* Map View */
        #map { height: 100%; width: 100%; }
        #controls {
            position: absolute;
            top: 60px;
            right: 10px;
            z-index: 1000;
            background: white;
            padding: 12px;
            border-radius: 6px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            width: 240px;
            font-size: 12px;
        }
        #controls label { display: block; margin-bottom: 4px; font-size: 12px; color: #666; }
        #controls input[type="date"] { width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; }
        #controls input[type="range"] { width: 100%; }
        .section-header {
            font-weight: 600;
            color: #333;
            margin: 12px 0 8px 0;
            padding-bottom: 4px;
            border-bottom: 1px solid #eee;
        }
        .section-header:first-child { margin-top: 0; }
        .pipeline-stage {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px;
            margin: 4px 0;
            background: #f8f8f8;
            border-radius: 4px;
        }
        .pipeline-stage input[type="checkbox"] { margin: 0; }
        .pipeline-stage .stage-name { flex: 1; }
        .pipeline-stage .stage-value { 
            font-size: 11px; 
            color: #666;
            min-width: 35px;
            text-align: right;
        }
        .pipeline-arrows {
            display: flex;
            flex-direction: column;
            gap: 1px;
        }
        .pipeline-arrows button {
            background: none;
            border: 1px solid #ddd;
            border-radius: 2px;
            cursor: pointer;
            padding: 0 4px;
            font-size: 10px;
            line-height: 1.2;
            color: #666;
        }
        .pipeline-arrows button:hover { background: #eee; }
        .pipeline-arrows button:disabled { opacity: 0.3; cursor: default; }
        .show-removed {
            display: flex;
            align-items: center;
            gap: 6px;
            margin: 4px 0;
        }
        .show-removed input[type="checkbox"] { margin: 0; }
        .show-removed .count { 
            font-size: 11px; 
            color: #999;
            margin-left: auto;
        }
        .slider-row {
            margin: 8px 0;
        }
        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 2px;
        }
        #status {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.5); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }
        .current-marker {
            animation: pulse 2s infinite;
            background: transparent !important;
            border: none !important;
        }

        /* Photo markers */
        .photo-marker {
            background: transparent !important;
            border: none !important;
        }
        .photo-thumb {
            position: relative;
            width: 48px;
            height: 48px;
            background-size: cover;
            background-position: center;
            outline: 2px solid white;
            border-radius: 4px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.4);
        }
        .photo-badge {
            position: absolute;
            bottom: 0;
            right: 0;
            background: rgba(0,0,0,0.75);
            color: white;
            font-size: 10px;
            padding: 1px 4px;
            border-radius: 3px 0 4px 0;
            font-weight: 500;
        }
        .photo-grid {
            display: grid;
            grid-template-columns: repeat(3, 120px);
            gap: 6px;
            max-height: 400px;
            overflow-y: auto;
            padding: 4px;
        }
        .photo-grid a {
            display: block;
            width: 120px;
            height: 120px;
        }
        .photo-grid img {
            width: 120px;
            height: 120px;
            object-fit: cover;
            border-radius: 4px;
            cursor: pointer;
        }
        .photo-grid img:hover { opacity: 0.85; }
    </style>
</head>
<body>
    <div id="nav">
        <a href="/" class="active">Map</a>
        <a href="/import">Import</a>
    </div>

    <div id="map"></div>
    <div id="controls">
        <div class="section-header">Date</div>
        <input type="date" id="dateFilter">

        <div class="section-header">Simplification Pipeline</div>
        <div id="pipeline">
            <div class="pipeline-stage" data-stage="stationary">
                <input type="checkbox" id="stationaryEnabled" checked>
                <span class="stage-name">Stationary</span>
                <span class="stage-value" id="stationaryValue">50m</span>
                <div class="pipeline-arrows">
                    <button class="move-up" title="Move up">^</button>
                    <button class="move-down" title="Move down">v</button>
                </div>
            </div>
            <div class="slider-row" id="stationarySliderRow">
                <input type="range" id="stationarySlider" min="0" max="200" value="50" step="5">
            </div>
            <div class="pipeline-stage" data-stage="spikes">
                <input type="checkbox" id="spikesEnabled" checked>
                <span class="stage-name">Spikes</span>
                <span class="stage-value" id="spikesValue">50m</span>
                <div class="pipeline-arrows">
                    <button class="move-up" title="Move up">^</button>
                    <button class="move-down" title="Move down">v</button>
                </div>
            </div>
            <div class="slider-row" id="spikesSliderRow">
                <input type="range" id="spikesSlider" min="0" max="200" value="50" step="5">
            </div>
        </div>

        <div class="section-header">Show Removed</div>
        <div class="show-removed">
            <input type="checkbox" id="showStationary">
            <label for="showStationary">Stationary</label>
            <span class="count" id="stationaryCount">(0)</span>
        </div>
        <div class="show-removed">
            <input type="checkbox" id="showSpikes">
            <label for="showSpikes">Spikes</label>
            <span class="count" id="spikesCount">(0)</span>
        </div>
    </div>
    <div id="status">Paths: 0, Points: 0</div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
    <script>
        // Map initialization
        const map = L.map('map').setView([0, 0], 2);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap contributors'
        }).addTo(map);

        let pathsLayer = L.layerGroup().addTo(map);
        let currentLayer = L.layerGroup().addTo(map);
        let photosLayer = L.layerGroup().addTo(map);
        let removedStationaryLayer = L.layerGroup();
        let removedSpikesLayer = L.layerGroup();

        // Store last response for re-rendering removed points
        let lastPathsData = null;

        // Pipeline state
        const pipeline = [
            { id: 'stationary', enabled: true, threshold: 50 },
            { id: 'spikes', enabled: true, threshold: 50 }
        ];

        function formatDateTime(timestamp) {
            const d = new Date(timestamp * 1000);
            const now = new Date();
            const isToday = d.toDateString() === now.toDateString();
            const yesterday = new Date(now);
            yesterday.setDate(yesterday.getDate() - 1);
            const isYesterday = d.toDateString() === yesterday.toDateString();

            const time = d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

            if (isToday) {
                return `Today ${time}`;
            } else if (isYesterday) {
                return `Yesterday ${time}`;
            } else {
                const date = d.toLocaleDateString(undefined, { month: 'short', day: 'numeric', year: 'numeric' });
                return `${date} ${time}`;
            }
        }

        function formatDuration(seconds) {
            const mins = Math.floor(seconds / 60);
            const hrs = Math.floor(mins / 60);
            const days = Math.floor(hrs / 24);

            if (days > 0) {
                const remainingHrs = hrs % 24;
                return `${days}d ${remainingHrs}h`;
            }
            if (hrs > 0) {
                const remainingMins = mins % 60;
                return `${hrs}h ${remainingMins}m`;
            }
            return `${mins}m`;
        }

        // Minimum time gap (seconds) to consider a point as a "stop"
        const STOP_GAP_SECONDS = 10 * 60; // 10 minutes

        // Fetch and display photo source info in a popup
        async function loadPhotoSource(marker, timestamp) {
            try {
                const resp = await fetch(`/api/location/source?timestamp=${timestamp}`);
                const source = await resp.json();

                if (!source) return;

                const popup = marker.getPopup();
                const currentContent = popup.getContent();

                let photoHtml = '<div style="margin-top: 8px; border-top: 1px solid #eee; padding-top: 8px;">';

                // Add thumbnail
                photoHtml += `<a href="${source.web_url}" target="_blank" rel="noopener" style="display: block;">`;
                photoHtml += `<img src="/api/immich/assets/${source.source_id}/thumbnail" `;
                photoHtml += `style="max-width: 200px; max-height: 150px; border-radius: 4px; cursor: pointer;" `;
                photoHtml += `onerror="this.style.display='none'" />`;
                photoHtml += `</a>`;

                // Add metadata
                if (source.filename) {
                    photoHtml += `<div style="font-size: 11px; color: #666; margin-top: 4px;">`;
                    photoHtml += source.filename;
                    if (source.make || source.model) {
                        photoHtml += `<br>${[source.make, source.model].filter(Boolean).join(' ')}`;
                    }
                    photoHtml += `</div>`;
                }

                // Add link to Immich
                if (source.web_url) {
                    photoHtml += `<a href="${source.web_url}" target="_blank" rel="noopener" `;
                    photoHtml += `style="font-size: 11px; color: #007bff; text-decoration: none;">`;
                    photoHtml += `View in Immich &rarr;</a>`;
                }

                photoHtml += '</div>';

                popup.setContent(currentContent + photoHtml);
                popup.update();
            } catch (err) {
                console.error('Failed to load photo source:', err);
            }
        }

        function renderPaths(data) {
            pathsLayer.clearLayers();
            currentLayer.clearLayers();

            if (data.paths) {
                data.paths.forEach(path => {
                    if (!path.points || path.points.length === 0) return;

                    const latlngs = path.points.map(p => [p.lat, p.lon]);

                    // Draw the path line
                    const polyline = L.polyline(latlngs, {
                        color: '#3498db',
                        weight: 3,
                        opacity: 0.8
                    }).bindPopup(`
                        <strong>${path.date}</strong><br>
                        ${path.point_count} points
                    `).addTo(pathsLayer);

                    // Add direction arrows along the path
                    addDirectionArrows(polyline, pathsLayer);

                    // Detect stops and add markers
                    for (let i = 0; i < path.points.length; i++) {
                        const point = path.points[i];
                        const nextPoint = path.points[i + 1];

                        let isStop = false;
                        let stopDuration = 0;

                        if (nextPoint) {
                            stopDuration = nextPoint.timestamp - point.timestamp;
                            isStop = stopDuration >= STOP_GAP_SECONDS;
                        } else if (i === path.points.length - 1 && path.points.length > 1) {
                            isStop = true;
                        }

                        if (i === 0) {
                            const startMarker = L.circleMarker([point.lat, point.lon], {
                                radius: 7,
                                fillColor: '#27ae60',
                                color: '#1e8449',
                                weight: 2,
                                opacity: 1,
                                fillOpacity: 0.9
                            }).bindPopup(`<strong>Start</strong><br>${formatDateTime(point.timestamp)}`)
                              .addTo(pathsLayer);
                            startMarker.on('popupopen', () => loadPhotoSource(startMarker, point.timestamp));
                        } else if (isStop) {
                            const popupContent = stopDuration > 0
                                ? `<strong>Stopped ${formatDuration(stopDuration)}</strong><br>${formatDateTime(point.timestamp)}`
                                : `<strong>End</strong><br>${formatDateTime(point.timestamp)}`;

                            const stopMarker = L.circleMarker([point.lat, point.lon], {
                                radius: 7,
                                fillColor: '#e74c3c',
                                color: '#c0392b',
                                weight: 2,
                                opacity: 1,
                                fillOpacity: 0.9
                            }).bindPopup(popupContent)
                              .addTo(pathsLayer);
                            stopMarker.on('popupopen', () => loadPhotoSource(stopMarker, point.timestamp));
                        }
                    }
                });
            }

            if (data.current) {
                const currentIcon = L.divIcon({
                    className: 'current-marker',
                    html: `<div style="
                        width: 16px;
                        height: 16px;
                        background: #2ecc71;
                        border: 3px solid #27ae60;
                        border-radius: 50%;
                    "></div>`,
                    iconSize: [16, 16],
                    iconAnchor: [8, 8]
                });
                L.marker([data.current.lat, data.current.lon], { icon: currentIcon })
                    .bindPopup(`Current: ${formatDateTime(data.current.timestamp)}`)
                    .addTo(currentLayer);
            }

            const pathCount = data.paths ? data.paths.length : 0;
            const pointCount = data.paths ? data.paths.reduce((sum, p) => sum + (p.point_count || 0), 0) : 0;
            document.getElementById('status').textContent = `Paths: ${pathCount}, Points: ${pointCount}`;
        }

        function addDirectionArrows(polyline, layer) {
            const latlngs = polyline.getLatLngs();
            if (latlngs.length < 2) return;

            const totalPoints = latlngs.length;
            const arrowInterval = Math.max(1, Math.floor(totalPoints / 8));

            for (let i = arrowInterval; i < totalPoints - 1; i += arrowInterval) {
                const start = latlngs[i - 1];
                const end = latlngs[i];

                const angle = Math.atan2(end.lng - start.lng, end.lat - start.lat) * 180 / Math.PI;

                const arrowIcon = L.divIcon({
                    className: 'direction-arrow',
                    html: `<div style="
                        transform: rotate(${angle}deg);
                        color: #2980b9;
                        font-size: 14px;
                        font-weight: bold;
                        text-shadow: 0 0 2px white, 0 0 2px white;
                    ">&#9650;</div>`,
                    iconSize: [14, 14],
                    iconAnchor: [7, 7]
                });

                L.marker(end, { icon: arrowIcon, interactive: false }).addTo(layer);
            }
        }

        async function fetchPhotos() {
            const date = document.getElementById('dateFilter').value;
            if (!date) {
                photosLayer.clearLayers();
                return;
            }

            const [y, m, d] = date.split('-').map(Number);
            const start = Math.floor(new Date(y, m - 1, d).getTime() / 1000);
            const end = Math.floor(new Date(y, m - 1, d, 23, 59, 59, 999).getTime() / 1000);
            const bounds = map.getBounds();
            const bbox = [bounds.getWest(), bounds.getSouth(), bounds.getEast(), bounds.getNorth()].join(',');

            try {
                const resp = await fetch(`/api/photos?start=${start}&end=${end}&bbox=${bbox}`);
                const data = await resp.json();

                photosLayer.clearLayers();
                (data.clusters || []).forEach(c => {
                    const icon = L.divIcon({
                        className: 'photo-marker',
                        html: `<div class="photo-thumb" style="background-image: url('${c.thumbnail_url}')">
                                 ${c.count > 1 ? `<span class="photo-badge">+${c.count - 1}</span>` : ''}
                               </div>`,
                        iconSize: [48, 48],
                        iconAnchor: [24, 24]
                    });
                    L.marker([c.lat, c.lon], { icon, zIndexOffset: 500 })
                      .bindPopup(c.popup_html, { maxWidth: 420, maxHeight: 450 })
                      .addTo(photosLayer);
                });
            } catch (err) {
                console.error('Failed to fetch photos:', err);
            }
        }

        function fetchPaths() {
            const bounds = map.getBounds();
            const bbox = [
                bounds.getWest(),
                bounds.getSouth(),
                bounds.getEast(),
                bounds.getNorth()
            ].join(',');

            let url = `/api/paths?bbox=${bbox}`;
            const date = document.getElementById('dateFilter').value;
            if (date) {
                const [y, m, d] = date.split('-').map(Number);
                const start = new Date(y, m - 1, d);
                const end = new Date(y, m - 1, d, 23, 59, 59, 999);
                url += `&start=${Math.floor(start.getTime() / 1000)}`;
                url += `&end=${Math.floor(end.getTime() / 1000)}`;
            }

            // Build pipeline parameters from state
            const enabledStages = pipeline.filter(s => s.enabled);
            const order = enabledStages.map(s => s.id).join(',');
            if (order) {
                url += `&order=${order}`;
            }

            const stationary = pipeline.find(s => s.id === 'stationary');
            if (stationary && stationary.enabled && stationary.threshold > 0) {
                url += `&prune=${stationary.threshold}`;
            }

            const spikes = pipeline.find(s => s.id === 'spikes');
            if (spikes && spikes.enabled && spikes.threshold > 0) {
                url += `&spikes=${spikes.threshold}`;
            }

            fetch(url)
                .then(r => r.json())
                .then(data => {
                    lastPathsData = data;
                    renderPaths(data);
                    renderRemovedPoints(data);
                })
                .catch(err => console.error('Failed to fetch paths:', err));
        }

        function renderRemovedPoints(data) {
            removedStationaryLayer.clearLayers();
            removedSpikesLayer.clearLayers();

            const stationaryCount = data.removed?.stationary?.length || 0;
            const spikesCount = data.removed?.spikes?.length || 0;

            document.getElementById('stationaryCount').textContent = `(${stationaryCount})`;
            document.getElementById('spikesCount').textContent = `(${spikesCount})`;

            // Render removed stationary points as gray dots
            if (data.removed?.stationary) {
                data.removed.stationary.forEach(pt => {
                    L.circleMarker([pt.lat, pt.lon], {
                        radius: 4,
                        fillColor: '#888',
                        color: '#666',
                        weight: 1,
                        opacity: 0.7,
                        fillOpacity: 0.5
                    }).addTo(removedStationaryLayer);
                });
            }

            // Render removed spikes as purple dots
            if (data.removed?.spikes) {
                data.removed.spikes.forEach(pt => {
                    L.circleMarker([pt.lat, pt.lon], {
                        radius: 5,
                        fillColor: '#9b59b6',
                        color: '#8e44ad',
                        weight: 2,
                        opacity: 0.9,
                        fillOpacity: 0.7
                    }).bindPopup(`Spike removed<br>${formatDateTime(pt.timestamp)}`)
                      .addTo(removedSpikesLayer);
                });
            }
        }

        function onDateChange() {
            const date = document.getElementById('dateFilter').value;
            if (!date) {
                fetchPaths();
                fetchPhotos();
                return;
            }

            const [y, m, d] = date.split('-').map(Number);
            const start = Math.floor(new Date(y, m - 1, d).getTime() / 1000);
            const end = Math.floor(new Date(y, m - 1, d, 23, 59, 59, 999).getTime() / 1000);

            fetch(`/api/bounds?start=${start}&end=${end}`)
                .then(r => r.json())
                .then(bounds => {
                    if (bounds) {
                        map.fitBounds([
                            [bounds.min_lat, bounds.min_lon],
                            [bounds.max_lat, bounds.max_lon]
                        ], { padding: [20, 20] });
                    } else {
                        fetchPaths();
                        fetchPhotos();
                    }
                })
                .catch(() => {
                    fetchPaths();
                    fetchPhotos();
                });
        }

        map.on('moveend', () => {
            fetchPaths();
            fetchPhotos();
        });
        const now = new Date();
        document.getElementById('dateFilter').value = now.getFullYear() + '-' + String(now.getMonth() + 1).padStart(2, '0') + '-' + String(now.getDate()).padStart(2, '0');
        document.getElementById('dateFilter').addEventListener('change', onDateChange);

        // Pipeline controls
        function updatePipelineUI() {
            const pipelineEl = document.getElementById('pipeline');
            const stages = pipelineEl.querySelectorAll('.pipeline-stage');
            
            // Update arrow button states
            stages.forEach((stageEl, index) => {
                const upBtn = stageEl.querySelector('.move-up');
                const downBtn = stageEl.querySelector('.move-down');
                upBtn.disabled = index === 0;
                downBtn.disabled = index === stages.length - 1;
            });
        }

        function movePipelineStage(stageId, direction) {
            const index = pipeline.findIndex(s => s.id === stageId);
            if (index === -1) return;
            
            const newIndex = direction === 'up' ? index - 1 : index + 1;
            if (newIndex < 0 || newIndex >= pipeline.length) return;
            
            // Swap in state
            [pipeline[index], pipeline[newIndex]] = [pipeline[newIndex], pipeline[index]];
            
            // Swap in DOM
            const pipelineEl = document.getElementById('pipeline');
            const stages = Array.from(pipelineEl.querySelectorAll('.pipeline-stage'));
            const sliders = Array.from(pipelineEl.querySelectorAll('.slider-row'));
            
            // Clear and re-add in new order
            pipelineEl.innerHTML = '';
            pipeline.forEach(s => {
                const stageIndex = s.id === 'stationary' ? 0 : 1;
                pipelineEl.appendChild(stages[stageIndex]);
                pipelineEl.appendChild(sliders[stageIndex]);
            });
            
            updatePipelineUI();
            fetchPaths();
        }

        // Stationary slider
        const stationarySlider = document.getElementById('stationarySlider');
        const stationaryValue = document.getElementById('stationaryValue');
        const stationaryEnabled = document.getElementById('stationaryEnabled');
        
        stationarySlider.addEventListener('input', () => {
            const val = stationarySlider.value;
            stationaryValue.textContent = val == 0 ? 'Off' : val + 'm';
            pipeline.find(s => s.id === 'stationary').threshold = parseInt(val);
        });
        stationarySlider.addEventListener('change', fetchPaths);
        stationaryEnabled.addEventListener('change', () => {
            pipeline.find(s => s.id === 'stationary').enabled = stationaryEnabled.checked;
            fetchPaths();
        });

        // Spikes slider
        const spikesSlider = document.getElementById('spikesSlider');
        const spikesValue = document.getElementById('spikesValue');
        const spikesEnabled = document.getElementById('spikesEnabled');
        
        spikesSlider.addEventListener('input', () => {
            const val = spikesSlider.value;
            spikesValue.textContent = val == 0 ? 'Off' : val + 'm';
            pipeline.find(s => s.id === 'spikes').threshold = parseInt(val);
        });
        spikesSlider.addEventListener('change', fetchPaths);
        spikesEnabled.addEventListener('change', () => {
            pipeline.find(s => s.id === 'spikes').enabled = spikesEnabled.checked;
            fetchPaths();
        });

        // Move buttons
        document.querySelectorAll('.move-up').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const stageEl = e.target.closest('.pipeline-stage');
                movePipelineStage(stageEl.dataset.stage, 'up');
            });
        });
        document.querySelectorAll('.move-down').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const stageEl = e.target.closest('.pipeline-stage');
                movePipelineStage(stageEl.dataset.stage, 'down');
            });
        });

        // Show removed checkboxes
        document.getElementById('showStationary').addEventListener('change', (e) => {
            if (e.target.checked) {
                removedStationaryLayer.addTo(map);
            } else {
                removedStationaryLayer.remove();
            }
        });
        document.getElementById('showSpikes').addEventListener('change', (e) => {
            if (e.target.checked) {
                removedSpikesLayer.addTo(map);
            } else {
                removedSpikesLayer.remove();
            }
        });

        updatePipelineUI();

        // Initial load: fit to today's bounds
        onDateChange();
    </script>
</body>
</html>
