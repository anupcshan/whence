<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Whence - Location History</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; font-family: system-ui, -apple-system, sans-serif; }

        /* Navigation */
        #nav {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: white;
            padding: 6px;
            border-radius: 6px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            display: flex;
            gap: 4px;
        }
        #nav a {
            padding: 8px 16px;
            border: none;
            background: transparent;
            cursor: pointer;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 500;
            text-decoration: none;
            color: inherit;
        }
        #nav a:hover { background: #f0f0f0; }
        #nav a.active { background: #007bff; color: white; }

        /* Date Navigation */
        #date-nav {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: white;
            padding: 4px;
            border-radius: 6px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            gap: 2px;
        }
        #date-nav button {
            padding: 6px 12px;
            border: none;
            background: transparent;
            cursor: pointer;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 600;
            color: #333;
        }
        #date-nav button:hover { background: #f0f0f0; }
        #date-display {
            padding: 6px 12px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            border-radius: 4px;
            min-width: 140px;
            text-align: center;
        }
        #date-display:hover { background: #f0f0f0; }
        #dateFilter {
            position: absolute;
            opacity: 0;
            width: 0;
            height: 0;
            pointer-events: none;
        }

        /* Map View */
        #map { height: 100%; width: 100%; }
        body.popup-open #nav,
        body.popup-open #date-nav { display: none; }

        /* Settings FAB */
        #settings-fab {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: white;
            border: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            cursor: pointer;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s;
        }
        #settings-fab:hover { transform: scale(1.1); }
        #settings-fab.active { background: #007bff; color: white; }

        /* Settings Panel */
        #controls {
            position: absolute;
            bottom: 80px;
            right: 20px;
            z-index: 1000;
            background: white;
            padding: 12px;
            border-radius: 6px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            width: 240px;
            font-size: 12px;
            display: none;
        }
        #controls.open { display: block; }
        #controls label { display: block; margin-bottom: 4px; font-size: 12px; color: #666; }
        #controls input[type="range"] { width: 100%; }
        .section-header {
            font-weight: 600;
            color: #333;
            margin: 12px 0 8px 0;
            padding-bottom: 4px;
            border-bottom: 1px solid #eee;
        }
        .section-header:first-child { margin-top: 0; }
        .pipeline-stage {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px;
            margin: 4px 0;
            background: #f8f8f8;
            border-radius: 4px;
        }
        .pipeline-stage input[type="checkbox"] { margin: 0; }
        .pipeline-stage .stage-name { flex: 1; }
        .pipeline-stage .stage-value {
            font-size: 11px;
            color: #666;
            min-width: 35px;
            text-align: right;
        }
        .pipeline-arrows {
            display: flex;
            flex-direction: column;
            gap: 1px;
        }
        .pipeline-arrows button {
            background: none;
            border: 1px solid #ddd;
            border-radius: 2px;
            cursor: pointer;
            padding: 0 4px;
            font-size: 10px;
            line-height: 1.2;
            color: #666;
        }
        .pipeline-arrows button:hover { background: #eee; }
        .pipeline-arrows button:disabled { opacity: 0.3; cursor: default; }
        .show-removed {
            display: flex;
            align-items: center;
            gap: 6px;
            margin: 4px 0;
        }
        .show-removed input[type="checkbox"] { margin: 0; }
        .show-removed .count {
            font-size: 11px;
            color: #999;
            margin-left: auto;
        }
        .slider-row {
            margin: 8px 0;
        }
        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 2px;
        }
        #status {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.5); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }
        .current-marker {
            animation: pulse 2s infinite;
            background: transparent !important;
            border: none !important;
        }
        .current-marker-circle {
            animation: pulse 2s infinite;
            transform-origin: center;
            transform-box: fill-box;
        }

        /* Photo markers */
        .photo-marker {
            background: transparent !important;
            border: none !important;
        }
        .photo-thumb {
            position: relative;
            width: 48px;
            height: 48px;
            background-size: cover;
            background-position: center;
            outline: 2px solid white;
            border-radius: 4px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.4);
        }
        .photo-badge {
            position: absolute;
            bottom: 0;
            right: 0;
            background: rgba(0,0,0,0.75);
            color: white;
            font-size: 10px;
            padding: 1px 4px;
            border-radius: 3px 0 4px 0;
            font-weight: 500;
        }
        .photo-grid {
            display: grid;
            grid-template-columns: repeat(3, 120px);
            gap: 6px;
            max-height: 400px;
            overflow-y: auto;
            padding: 4px;
        }
        .photo-grid-1 { grid-template-columns: 120px; }
        .photo-grid-2 { grid-template-columns: repeat(2, 120px); }
        .photo-grid a {
            display: block;
            width: 120px;
            height: 120px;
        }
        .photo-grid img {
            width: 120px;
            height: 120px;
            object-fit: cover;
            border-radius: 4px;
            cursor: pointer;
        }
        .photo-grid img:hover { opacity: 0.85; }

        /* Timeline Panel */
        #timeline-toggle {
            position: absolute;
            top: 120px;
            right: 20px;
            z-index: 1000;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: white;
            border: none;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #timeline-toggle:hover { background: #f0f0f0; }
        #timeline-toggle.active { background: #007bff; color: white; }

        #timeline-panel {
            position: absolute;
            top: 0;
            right: 0;
            width: 320px;
            height: 100%;
            background: white;
            box-shadow: -2px 0 8px rgba(0,0,0,0.15);
            z-index: 900;
            display: flex;
            flex-direction: column;
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }
        #timeline-panel.open { transform: translateX(0); }
        body.timeline-open #map { width: calc(100% - 320px); }
        body.timeline-open #timeline-toggle { right: 340px; }

        .timeline-header {
            padding: 16px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        .timeline-header h2 {
            font-size: 16px;
            font-weight: 600;
            margin: 0;
        }
        .timeline-close {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 20px;
            color: #666;
            padding: 0 4px;
        }
        .timeline-close:hover { color: #333; }

        .timeline-entries {
            flex: 1;
            overflow-y: auto;
            padding: 8px 0;
        }

        .timeline-entry {
            padding: 12px 16px;
            border-bottom: 1px solid #f0f0f0;
            cursor: pointer;
            transition: background 0.15s;
        }
        .timeline-entry:hover { background: #f8f9fa; }
        .timeline-entry.active {
            background: #e7f1ff;
            border-left: 3px solid #007bff;
            padding-left: 13px;
        }
        .timeline-entry.travel {
            background: #fafafa;
            padding: 8px 16px;
            border-left: 2px dashed #ccc;
        }
        .timeline-entry.travel:hover { background: #f5f5f5; }
        .timeline-travel-info {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #888;
            font-size: 13px;
        }
        .timeline-travel-icon {
            font-size: 14px;
            color: #666;
        }
        .timeline-travel-distance {
            color: #666;
        }

        .timeline-time {
            font-size: 12px;
            color: #666;
            font-weight: 500;
        }
        .timeline-place {
            font-size: 14px;
            font-weight: 500;
            margin: 4px 0;
            color: #333;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .timeline-place::before {
            content: "";
            display: inline-block;
            width: 8px;
            height: 8px;
            background: #e74c3c;
            border-radius: 50%;
            flex-shrink: 0;
        }
        .timeline-duration {
            font-size: 12px;
            color: #888;
        }

        .timeline-photos {
            display: flex;
            gap: 4px;
            margin-top: 8px;
            overflow-x: auto;
            padding-bottom: 4px;
        }
        .timeline-photo {
            width: 48px;
            height: 48px;
            border-radius: 4px;
            object-fit: cover;
            flex-shrink: 0;
            cursor: pointer;
        }
        .timeline-photo:hover { opacity: 0.85; }
        .timeline-more {
            display: flex;
            align-items: center;
            padding: 0 8px;
            font-size: 12px;
            color: #666;
            flex-shrink: 0;
        }

        .timeline-empty {
            padding: 24px 16px;
            text-align: center;
            color: #666;
        }
        .timeline-loading {
            padding: 24px 16px;
            text-align: center;
            color: #666;
        }

        /* Mobile responsiveness for timeline */
        @media (max-width: 768px) {
            #timeline-panel {
                width: 100%;
                height: 50%;
                top: auto;
                bottom: 0;
                transform: translateY(100%);
                border-radius: 16px 16px 0 0;
            }
            #timeline-panel.open { transform: translateY(0); }
            body.timeline-open #map { width: 100%; height: 50%; }
            body.timeline-open #timeline-toggle { right: 20px; bottom: calc(50% + 20px); top: auto; }
            #timeline-toggle { bottom: 80px; top: auto; }
        }
    </style>
</head>
<body>
    <div id="nav">
        <a href="/" class="active">Map</a>
        <a href="/import">Import</a>
    </div>

    <div id="date-nav">
        <button id="date-prev" title="Previous day">&lt;</button>
        <span id="date-display"></span>
        <input type="date" id="dateFilter">
        <button id="date-next" title="Next day">&gt;</button>
    </div>

    <div id="map"></div>
    <button id="settings-fab" title="Options">&#9881;</button>
    <div id="controls">
        <div class="section-header">Simplification Pipeline</div>
        <div id="pipeline">
            <div class="pipeline-stage" data-stage="stationary">
                <input type="checkbox" id="stationaryEnabled" checked>
                <span class="stage-name">Stationary</span>
                <span class="stage-value" id="stationaryValue">50m</span>
                <div class="pipeline-arrows">
                    <button class="move-up" title="Move up">^</button>
                    <button class="move-down" title="Move down">v</button>
                </div>
            </div>
            <div class="slider-row" id="stationarySliderRow">
                <input type="range" id="stationarySlider" min="0" max="200" value="50" step="5">
            </div>
            <div class="pipeline-stage" data-stage="spikes">
                <input type="checkbox" id="spikesEnabled" checked>
                <span class="stage-name">Spikes</span>
                <span class="stage-value" id="spikesValue">50m</span>
                <div class="pipeline-arrows">
                    <button class="move-up" title="Move up">^</button>
                    <button class="move-down" title="Move down">v</button>
                </div>
            </div>
            <div class="slider-row" id="spikesSliderRow">
                <input type="range" id="spikesSlider" min="0" max="200" value="50" step="5">
            </div>
        </div>

        <div class="section-header">Show Removed</div>
        <div class="show-removed">
            <input type="checkbox" id="showStationary">
            <label for="showStationary">Stationary</label>
            <span class="count" id="stationaryCount">(0)</span>
        </div>
        <div class="show-removed">
            <input type="checkbox" id="showSpikes">
            <label for="showSpikes">Spikes</label>
            <span class="count" id="spikesCount">(0)</span>
        </div>
    </div>
    <div id="status">Paths: 0, Points: 0</div>

    <!-- Timeline toggle and panel -->
    <button id="timeline-toggle" title="Timeline">&#128203;</button>
    <div id="timeline-panel">
        <div class="timeline-header">
            <h2>Timeline</h2>
            <button class="timeline-close" title="Close">&times;</button>
        </div>
        <div class="timeline-entries" id="timeline-entries">
            <div class="timeline-empty">Select a date to view timeline</div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
    <script>
        // Map initialization
        const map = L.map('map').setView([0, 0], 2);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap contributors'
        }).addTo(map);

        let pathsLayer = L.layerGroup().addTo(map);
        let currentLayer = L.layerGroup().addTo(map);
        let photosLayer = L.layerGroup().addTo(map);
        let removedStationaryLayer = L.layerGroup();
        let removedSpikesLayer = L.layerGroup();

        // Store last response for re-rendering removed points
        let lastPathsData = null;

        // Pipeline state
        const pipeline = [
            { id: 'stationary', enabled: true, threshold: 50 },
            { id: 'spikes', enabled: true, threshold: 50 }
        ];

        function formatDateTime(timestamp) {
            const d = new Date(timestamp * 1000);
            const now = new Date();
            const isToday = d.toDateString() === now.toDateString();
            const yesterday = new Date(now);
            yesterday.setDate(yesterday.getDate() - 1);
            const isYesterday = d.toDateString() === yesterday.toDateString();

            const time = d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

            if (isToday) {
                return `Today ${time}`;
            } else if (isYesterday) {
                return `Yesterday ${time}`;
            } else {
                const date = d.toLocaleDateString(undefined, { month: 'short', day: 'numeric', year: 'numeric' });
                return `${date} ${time}`;
            }
        }

        function formatDuration(seconds) {
            const mins = Math.floor(seconds / 60);
            const hrs = Math.floor(mins / 60);
            const days = Math.floor(hrs / 24);

            if (days > 0) {
                const remainingHrs = hrs % 24;
                return `${days}d ${remainingHrs}h`;
            }
            if (hrs > 0) {
                const remainingMins = mins % 60;
                return `${hrs}h ${remainingMins}m`;
            }
            return `${mins}m`;
        }

        // Minimum time gap (seconds) to consider a point as a "stop"
        const STOP_GAP_SECONDS = 10 * 60; // 10 minutes

        // Fetch and display photo source info in a popup
        async function loadPhotoSource(marker, timestamp) {
            try {
                const resp = await fetch(`/api/location/source?timestamp=${timestamp}`);
                const source = await resp.json();

                if (!source) return;

                const popup = marker.getPopup();
                const currentContent = popup.getContent();

                // Use my.immich.app for deep linking to the Immich mobile app
                const appUrl = `https://my.immich.app/photos/${source.source_id}`;

                let photoHtml = '<div style="margin-top: 8px; border-top: 1px solid #eee; padding-top: 8px;">';

                // Add thumbnail (links to Immich app via my.immich.app)
                photoHtml += `<a href="${appUrl}" style="display: block;">`;
                photoHtml += `<img src="/api/immich/assets/${source.source_id}/thumbnail" `;
                photoHtml += `style="max-width: 200px; max-height: 150px; border-radius: 4px; cursor: pointer;" `;
                photoHtml += `onerror="this.style.display='none'" />`;
                photoHtml += `</a>`;

                // Add metadata
                if (source.filename) {
                    photoHtml += `<div style="font-size: 11px; color: #666; margin-top: 4px;">`;
                    photoHtml += source.filename;
                    if (source.make || source.model) {
                        photoHtml += `<br>${[source.make, source.model].filter(Boolean).join(' ')}`;
                    }
                    photoHtml += `</div>`;
                }

                // Add links to Immich (app and web)
                photoHtml += `<div style="margin-top: 4px;">`;
                photoHtml += `<a href="${appUrl}" style="font-size: 11px; color: #007bff; text-decoration: none;">`;
                photoHtml += `Open in App</a>`;
                if (source.web_url) {
                    photoHtml += `<span style="font-size: 11px; color: #999;"> Â· </span>`;
                    photoHtml += `<a href="${source.web_url}" target="_blank" rel="noopener" `;
                    photoHtml += `style="font-size: 11px; color: #007bff; text-decoration: none;">`;
                    photoHtml += `Web</a>`;
                }
                photoHtml += `</div>`;

                photoHtml += '</div>';

                popup.setContent(currentContent + photoHtml);
                popup.update();
            } catch (err) {
                console.error('Failed to load photo source:', err);
            }
        }

        function renderPaths(data) {
            pathsLayer.clearLayers();
            currentLayer.clearLayers();

            if (data.paths) {
                data.paths.forEach(path => {
                    if (!path.points || path.points.length === 0) return;

                    const latlngs = path.points.map(p => [p.lat, p.lon]);

                    // Draw the path line
                    const polyline = L.polyline(latlngs, {
                        color: '#3498db',
                        weight: 3,
                        opacity: 0.8
                    }).bindPopup(`
                        <strong>${path.date}</strong><br>
                        ${path.point_count} points
                    `).addTo(pathsLayer);

                    // Add direction arrows along the path
                    addDirectionArrows(polyline, pathsLayer);

                    // Detect stops and add markers
                    for (let i = 0; i < path.points.length; i++) {
                        const point = path.points[i];
                        const nextPoint = path.points[i + 1];

                        let isStop = false;
                        let stopDuration = 0;

                        if (nextPoint) {
                            stopDuration = nextPoint.timestamp - point.timestamp;
                            isStop = stopDuration >= STOP_GAP_SECONDS;
                        } else if (i === path.points.length - 1 && path.points.length > 1) {
                            isStop = true;
                        }

                        if (i === 0) {
                            const startMarker = L.circleMarker([point.lat, point.lon], {
                                radius: 7,
                                fillColor: '#27ae60',
                                color: '#1e8449',
                                weight: 2,
                                opacity: 1,
                                fillOpacity: 0.9
                            }).bindPopup(`<strong>Start</strong><br>${formatDateTime(point.timestamp)}`)
                              .addTo(pathsLayer);
                            startMarker.on('popupopen', () => loadPhotoSource(startMarker, point.timestamp));
                        } else if (isStop) {
                            const popupContent = stopDuration > 0
                                ? `<strong>Stopped ${formatDuration(stopDuration)}</strong><br>${formatDateTime(point.timestamp)}`
                                : `<strong>End</strong><br>${formatDateTime(point.timestamp)}`;

                            const stopMarker = L.circleMarker([point.lat, point.lon], {
                                radius: 7,
                                fillColor: '#e74c3c',
                                color: '#c0392b',
                                weight: 2,
                                opacity: 1,
                                fillOpacity: 0.9
                            }).bindPopup(popupContent)
                              .addTo(pathsLayer);
                            stopMarker.on('popupopen', () => loadPhotoSource(stopMarker, point.timestamp));
                        }
                    }
                });
            }

            if (data.current) {
                L.circleMarker([data.current.lat, data.current.lon], {
                    radius: 8,
                    fillColor: '#2ecc71',
                    color: '#27ae60',
                    weight: 3,
                    opacity: 1,
                    fillOpacity: 0.9,
                    className: 'current-marker-circle'
                }).bindPopup(`Current: ${formatDateTime(data.current.timestamp)}`)
                  .addTo(currentLayer);
            }

            const pathCount = data.paths ? data.paths.length : 0;
            const pointCount = data.paths ? data.paths.reduce((sum, p) => sum + (p.point_count || 0), 0) : 0;
            document.getElementById('status').textContent = `Paths: ${pathCount}, Points: ${pointCount}`;
        }

        function addDirectionArrows(polyline, layer) {
            const latlngs = polyline.getLatLngs();
            if (latlngs.length < 2) return;

            const totalPoints = latlngs.length;
            const arrowInterval = Math.max(1, Math.floor(totalPoints / 8));

            for (let i = arrowInterval; i < totalPoints - 1; i += arrowInterval) {
                const start = latlngs[i - 1];
                const end = latlngs[i];

                const angle = Math.atan2(end.lng - start.lng, end.lat - start.lat) * 180 / Math.PI;

                const arrowIcon = L.divIcon({
                    className: 'direction-arrow',
                    html: `<div style="
                        transform: rotate(${angle}deg);
                        color: #2980b9;
                        font-size: 14px;
                        font-weight: bold;
                        text-shadow: 0 0 2px white, 0 0 2px white;
                    ">&#9650;</div>`,
                    iconSize: [14, 14],
                    iconAnchor: [7, 7]
                });

                L.marker(end, { icon: arrowIcon, interactive: false }).addTo(layer);
            }
        }

        async function fetchPhotos() {
            const date = document.getElementById('dateFilter').value;
            if (!date) {
                photosLayer.clearLayers();
                return;
            }

            const [y, m, d] = date.split('-').map(Number);
            const start = Math.floor(new Date(y, m - 1, d).getTime() / 1000);
            const end = Math.floor(new Date(y, m - 1, d, 23, 59, 59, 999).getTime() / 1000);
            const bounds = map.getBounds();
            const bbox = [bounds.getWest(), bounds.getSouth(), bounds.getEast(), bounds.getNorth()].join(',');

            try {
                const resp = await fetch(`/api/photos?start=${start}&end=${end}&bbox=${bbox}`);
                const data = await resp.json();

                photosLayer.clearLayers();
                (data.clusters || []).forEach(c => {
                    const icon = L.divIcon({
                        className: 'photo-marker',
                        html: `<div class="photo-thumb" style="background-image: url('${c.thumbnail_url}')">
                                 ${c.count > 1 ? `<span class="photo-badge">+${c.count - 1}</span>` : ''}
                               </div>`,
                        iconSize: [48, 48],
                        iconAnchor: [24, 24]
                    });
                    L.marker([c.lat, c.lon], { icon, zIndexOffset: 500 })
                      .bindPopup(c.popup_html, { maxWidth: 420, maxHeight: 450, closeOnClick: false })
                      .addTo(photosLayer);
                });
            } catch (err) {
                console.error('Failed to fetch photos:', err);
            }
        }

        function fetchPaths() {
            const bounds = map.getBounds();
            const bbox = [
                bounds.getWest(),
                bounds.getSouth(),
                bounds.getEast(),
                bounds.getNorth()
            ].join(',');

            let url = `/api/paths?bbox=${bbox}`;
            const date = document.getElementById('dateFilter').value;
            if (date) {
                const [y, m, d] = date.split('-').map(Number);
                const start = new Date(y, m - 1, d);
                const end = new Date(y, m - 1, d, 23, 59, 59, 999);
                url += `&start=${Math.floor(start.getTime() / 1000)}`;
                url += `&end=${Math.floor(end.getTime() / 1000)}`;
            }

            // Build pipeline parameters from state
            const enabledStages = pipeline.filter(s => s.enabled);
            const order = enabledStages.map(s => s.id).join(',');
            if (order) {
                url += `&order=${order}`;
            }

            const stationary = pipeline.find(s => s.id === 'stationary');
            if (stationary && stationary.enabled && stationary.threshold > 0) {
                url += `&prune=${stationary.threshold}`;
            }

            const spikes = pipeline.find(s => s.id === 'spikes');
            if (spikes && spikes.enabled && spikes.threshold > 0) {
                url += `&spikes=${spikes.threshold}`;
            }

            fetch(url)
                .then(r => r.json())
                .then(data => {
                    lastPathsData = data;
                    renderPaths(data);
                    renderRemovedPoints(data);
                })
                .catch(err => console.error('Failed to fetch paths:', err));
        }

        function renderRemovedPoints(data) {
            removedStationaryLayer.clearLayers();
            removedSpikesLayer.clearLayers();

            const stationaryCount = data.removed?.stationary?.length || 0;
            const spikesCount = data.removed?.spikes?.length || 0;

            document.getElementById('stationaryCount').textContent = `(${stationaryCount})`;
            document.getElementById('spikesCount').textContent = `(${spikesCount})`;

            // Render removed stationary points as gray dots
            if (data.removed?.stationary) {
                data.removed.stationary.forEach(pt => {
                    L.circleMarker([pt.lat, pt.lon], {
                        radius: 4,
                        fillColor: '#888',
                        color: '#666',
                        weight: 1,
                        opacity: 0.7,
                        fillOpacity: 0.5
                    }).addTo(removedStationaryLayer);
                });
            }

            // Render removed spikes as purple dots
            if (data.removed?.spikes) {
                data.removed.spikes.forEach(pt => {
                    L.circleMarker([pt.lat, pt.lon], {
                        radius: 5,
                        fillColor: '#9b59b6',
                        color: '#8e44ad',
                        weight: 2,
                        opacity: 0.9,
                        fillOpacity: 0.7
                    }).bindPopup(`Spike removed<br>${formatDateTime(pt.timestamp)}`)
                      .addTo(removedSpikesLayer);
                });
            }
        }

        function onDateChange() {
            const date = document.getElementById('dateFilter').value;
            if (!date) {
                fetchPaths();
                fetchPhotos();
                return;
            }

            const [y, m, d] = date.split('-').map(Number);
            const start = Math.floor(new Date(y, m - 1, d).getTime() / 1000);
            const end = Math.floor(new Date(y, m - 1, d, 23, 59, 59, 999).getTime() / 1000);

            fetch(`/api/bounds?start=${start}&end=${end}`)
                .then(r => r.json())
                .then(bounds => {
                    if (bounds) {
                        map.fitBounds([
                            [bounds.min_lat, bounds.min_lon],
                            [bounds.max_lat, bounds.max_lon]
                        ], { padding: [20, 20] });
                    } else {
                        fetchPaths();
                        fetchPhotos();
                    }
                })
                .catch(() => {
                    fetchPaths();
                    fetchPhotos();
                });
        }

        // Track if a popup is open to avoid refetching while viewing
        let popupOpen = false;
        map.on('popupopen', () => {
            popupOpen = true;
            document.body.classList.add('popup-open');
        });
        map.on('popupclose', () => {
            popupOpen = false;
            document.body.classList.remove('popup-open');
        });

        map.on('moveend', () => {
            fetchPaths();
            if (!popupOpen) {
                fetchPhotos();
            }
        });

        // Date navigation
        const dateFilter = document.getElementById('dateFilter');
        const dateDisplay = document.getElementById('date-display');
        const datePrev = document.getElementById('date-prev');
        const dateNext = document.getElementById('date-next');

        function formatDateDisplay(dateStr) {
            const [y, m, d] = dateStr.split('-').map(Number);
            const date = new Date(y, m - 1, d);
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const yesterday = new Date(today);
            yesterday.setDate(yesterday.getDate() - 1);

            if (date.getTime() === today.getTime()) {
                return 'Today';
            } else if (date.getTime() === yesterday.getTime()) {
                return 'Yesterday';
            } else {
                return date.toLocaleDateString(undefined, { weekday: 'short', month: 'short', day: 'numeric' });
            }
        }

        function updateDateDisplay() {
            dateDisplay.textContent = formatDateDisplay(dateFilter.value);
        }

        function changeDate(delta) {
            const [y, m, d] = dateFilter.value.split('-').map(Number);
            const date = new Date(y, m - 1, d);
            date.setDate(date.getDate() + delta);
            dateFilter.value = date.getFullYear() + '-' + String(date.getMonth() + 1).padStart(2, '0') + '-' + String(date.getDate()).padStart(2, '0');
            updateDateDisplay();
            onDateChange();
        }

        const now = new Date();
        dateFilter.value = now.getFullYear() + '-' + String(now.getMonth() + 1).padStart(2, '0') + '-' + String(now.getDate()).padStart(2, '0');
        updateDateDisplay();
        dateFilter.addEventListener('change', () => {
            updateDateDisplay();
            onDateChange();
        });
        dateDisplay.addEventListener('click', () => dateFilter.showPicker());
        datePrev.addEventListener('click', () => changeDate(-1));
        dateNext.addEventListener('click', () => changeDate(1));

        // Pipeline controls
        function updatePipelineUI() {
            const pipelineEl = document.getElementById('pipeline');
            const stages = pipelineEl.querySelectorAll('.pipeline-stage');

            // Update arrow button states
            stages.forEach((stageEl, index) => {
                const upBtn = stageEl.querySelector('.move-up');
                const downBtn = stageEl.querySelector('.move-down');
                upBtn.disabled = index === 0;
                downBtn.disabled = index === stages.length - 1;
            });
        }

        function movePipelineStage(stageId, direction) {
            const index = pipeline.findIndex(s => s.id === stageId);
            if (index === -1) return;

            const newIndex = direction === 'up' ? index - 1 : index + 1;
            if (newIndex < 0 || newIndex >= pipeline.length) return;

            // Swap in state
            [pipeline[index], pipeline[newIndex]] = [pipeline[newIndex], pipeline[index]];

            // Swap in DOM
            const pipelineEl = document.getElementById('pipeline');
            const stages = Array.from(pipelineEl.querySelectorAll('.pipeline-stage'));
            const sliders = Array.from(pipelineEl.querySelectorAll('.slider-row'));

            // Clear and re-add in new order
            pipelineEl.innerHTML = '';
            pipeline.forEach(s => {
                const stageIndex = s.id === 'stationary' ? 0 : 1;
                pipelineEl.appendChild(stages[stageIndex]);
                pipelineEl.appendChild(sliders[stageIndex]);
            });

            updatePipelineUI();
            fetchPaths();
        }

        // Stationary slider
        const stationarySlider = document.getElementById('stationarySlider');
        const stationaryValue = document.getElementById('stationaryValue');
        const stationaryEnabled = document.getElementById('stationaryEnabled');

        stationarySlider.addEventListener('input', () => {
            const val = stationarySlider.value;
            stationaryValue.textContent = val == 0 ? 'Off' : val + 'm';
            pipeline.find(s => s.id === 'stationary').threshold = parseInt(val);
        });
        stationarySlider.addEventListener('change', fetchPaths);
        stationaryEnabled.addEventListener('change', () => {
            pipeline.find(s => s.id === 'stationary').enabled = stationaryEnabled.checked;
            fetchPaths();
        });

        // Spikes slider
        const spikesSlider = document.getElementById('spikesSlider');
        const spikesValue = document.getElementById('spikesValue');
        const spikesEnabled = document.getElementById('spikesEnabled');

        spikesSlider.addEventListener('input', () => {
            const val = spikesSlider.value;
            spikesValue.textContent = val == 0 ? 'Off' : val + 'm';
            pipeline.find(s => s.id === 'spikes').threshold = parseInt(val);
        });
        spikesSlider.addEventListener('change', fetchPaths);
        spikesEnabled.addEventListener('change', () => {
            pipeline.find(s => s.id === 'spikes').enabled = spikesEnabled.checked;
            fetchPaths();
        });

        // Move buttons
        document.querySelectorAll('.move-up').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const stageEl = e.target.closest('.pipeline-stage');
                movePipelineStage(stageEl.dataset.stage, 'up');
            });
        });
        document.querySelectorAll('.move-down').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const stageEl = e.target.closest('.pipeline-stage');
                movePipelineStage(stageEl.dataset.stage, 'down');
            });
        });

        // Show removed checkboxes
        document.getElementById('showStationary').addEventListener('change', (e) => {
            if (e.target.checked) {
                removedStationaryLayer.addTo(map);
            } else {
                removedStationaryLayer.remove();
            }
        });
        document.getElementById('showSpikes').addEventListener('change', (e) => {
            if (e.target.checked) {
                removedSpikesLayer.addTo(map);
            } else {
                removedSpikesLayer.remove();
            }
        });

        // Settings FAB toggle
        const settingsFab = document.getElementById('settings-fab');
        const controlsPanel = document.getElementById('controls');

        settingsFab.addEventListener('click', () => {
            settingsFab.classList.toggle('active');
            controlsPanel.classList.toggle('open');
        });

        // Close panel when clicking outside
        document.addEventListener('click', (e) => {
            if (!controlsPanel.contains(e.target) && !settingsFab.contains(e.target)) {
                settingsFab.classList.remove('active');
                controlsPanel.classList.remove('open');
            }
        });

        updatePipelineUI();

        // Timeline functionality
        let timelineOpen = false;
        let timelineData = null;

        const timelinePanel = document.getElementById('timeline-panel');
        const timelineToggle = document.getElementById('timeline-toggle');
        const timelineClose = document.querySelector('.timeline-close');
        const timelineEntries = document.getElementById('timeline-entries');

        function toggleTimeline() {
            timelineOpen = !timelineOpen;
            timelinePanel.classList.toggle('open', timelineOpen);
            timelineToggle.classList.toggle('active', timelineOpen);
            document.body.classList.toggle('timeline-open', timelineOpen);

            // Trigger map resize after transition
            setTimeout(() => map.invalidateSize(), 300);

            if (timelineOpen && !timelineData) {
                fetchTimeline();
            }
        }

        timelineToggle.addEventListener('click', toggleTimeline);
        timelineClose.addEventListener('click', toggleTimeline);

        async function fetchTimeline() {
            const date = document.getElementById('dateFilter').value;
            if (!date) {
                timelineEntries.innerHTML = '<div class="timeline-empty">Select a date to view timeline</div>';
                return;
            }

            timelineEntries.innerHTML = '<div class="timeline-loading">Loading...</div>';

            try {
                const resp = await fetch(`/api/timeline?date=${date}`);
                if (!resp.ok) throw new Error('Failed to fetch timeline');

                timelineData = await resp.json();
                renderTimeline(timelineData);
            } catch (err) {
                console.error('Timeline fetch error:', err);
                timelineEntries.innerHTML = '<div class="timeline-empty" style="color: #e74c3c;">Failed to load timeline</div>';
            }
        }

        function formatTimeOnly(timestamp) {
            const d = new Date(timestamp * 1000);
            return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        }

        function formatDurationShort(seconds) {
            if (seconds < 60) return '<1m';
            if (seconds < 3600) return Math.round(seconds / 60) + 'm';
            // Use floor for minutes to avoid "7h 60m" when rounding up
            const hours = Math.floor(seconds / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            return mins > 0 ? `${hours}h ${mins}m` : `${hours}h`;
        }

        function formatDistance(meters, locale = navigator.language) {
            // Locales that typically use imperial units
            const imperialLocales = ['en-US', 'en-GB', 'my']; // US, UK (for roads), Myanmar
            const useImperial = imperialLocales.some(loc => locale.startsWith(loc.split('-')[0]) && locale === loc);

            let value, unit;
            if (useImperial) {
                const feet = meters * 3.28084;
                if (feet >= 5280) {
                    value = feet / 5280;
                    unit = 'mile';
                } else {
                    value = feet;
                    unit = 'foot';
                }
            } else {
                if (meters >= 1000) {
                    value = meters / 1000;
                    unit = 'kilometer';
                } else {
                    value = meters;
                    unit = 'meter';
                }
            }

            return new Intl.NumberFormat(locale, {
                style: 'unit',
                unit: unit,
                unitDisplay: 'short',
                maximumFractionDigits: 1
            }).format(value);
        }

        function renderTimeline(data) {
            if (!data.entries || data.entries.length === 0) {
                timelineEntries.innerHTML = '<div class="timeline-empty">No locations for this date</div>';
                return;
            }

            timelineEntries.innerHTML = data.entries.map((entry, index) => {
                const time = formatTimeOnly(entry.timestamp);
                const duration = entry.duration_seconds ? formatDurationShort(entry.duration_seconds) : '';

                // Handle travel entries differently
                if (entry.type === 'travel') {
                    const distance = entry.distance_meters ? formatDistance(entry.distance_meters) : '';
                    return `
                        <div class="timeline-entry travel" data-index="${index}" data-lat="${entry.lat}" data-lon="${entry.lon}" data-end-lat="${entry.end_lat || ''}" data-end-lon="${entry.end_lon || ''}">
                            <div class="timeline-travel-info">
                                <span class="timeline-travel-icon">&#8594;</span>
                                <span>Travel</span>
                                ${distance ? `<span class="timeline-travel-distance">${distance}</span>` : ''}
                                ${duration ? `<span>${duration}</span>` : ''}
                            </div>
                        </div>
                    `;
                }

                // Stop entry
                const placeName = entry.place_name || 'Unknown location';

                let photosHtml = '';
                if (entry.photos && entry.photos.length > 0) {
                    const maxPhotos = 4;
                    const visiblePhotos = entry.photos.slice(0, maxPhotos);
                    const remainingCount = entry.photos.length - maxPhotos;

                    photosHtml = '<div class="timeline-photos">' +
                        visiblePhotos.map(p =>
                            `<img class="timeline-photo" src="${p.thumbnail_url}" alt="${p.filename || ''}" title="${p.filename || ''}">`
                        ).join('') +
                        (remainingCount > 0 ? `<span class="timeline-more">+${remainingCount}</span>` : '') +
                        '</div>';
                }

                return `
                    <div class="timeline-entry" data-index="${index}" data-lat="${entry.lat}" data-lon="${entry.lon}">
                        <div class="timeline-time">${time}</div>
                        <div class="timeline-place">${placeName}</div>
                        ${duration ? `<div class="timeline-duration">${duration}</div>` : ''}
                        ${photosHtml}
                    </div>
                `;
            }).join('');

            // Add click handlers for entries
            timelineEntries.querySelectorAll('.timeline-entry').forEach(el => {
                el.addEventListener('click', () => {
                    const lat = parseFloat(el.dataset.lat);
                    const lon = parseFloat(el.dataset.lon);

                    // For travel entries, fit to show both start and end
                    if (el.classList.contains('travel') && el.dataset.endLat && el.dataset.endLon) {
                        const endLat = parseFloat(el.dataset.endLat);
                        const endLon = parseFloat(el.dataset.endLon);
                        map.fitBounds([[lat, lon], [endLat, endLon]], { padding: [50, 50] });
                    } else {
                        // Center map on this location
                        map.setView([lat, lon], 16);
                    }

                    // Highlight the selected entry
                    timelineEntries.querySelectorAll('.timeline-entry').forEach(e => e.classList.remove('active'));
                    el.classList.add('active');
                });
            });
        }

        // Hook timeline refresh into date changes
        const originalOnDateChange = onDateChange;
        onDateChange = function() {
            originalOnDateChange();
            timelineData = null; // Clear cached data
            if (timelineOpen) {
                fetchTimeline();
            }
        };

        // Initial load: fit to today's bounds
        onDateChange();
    </script>
</body>
</html>
